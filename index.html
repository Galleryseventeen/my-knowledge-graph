<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Node Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f5f4f0;
            color: #333;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #graph-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        svg {
            background: #f5f4f0;
            cursor: grab;
        }

        svg:active {
            cursor: grabbing;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            transform: scale(1.1);
        }

        .node circle {
            fill: #6366f1;
            stroke: none;
        }

        .node.central circle {
            fill: #2d2d2d;
        }

        .node.external circle {
            fill: #6366f1;
        }

        .node text {
            fill: #333;
            font-size: 11px;
            font-weight: 400;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .node:hover text {
            opacity: 1;
        }

        .hover-preview {
            position: absolute;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 14px;
            line-height: 1.4;
        }

        .hover-preview.visible {
            opacity: 1;
        }

        .preview-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #111827;
        }

        .preview-content {
            color: #374151;
            margin-bottom: 8px;
        }

        .preview-meta {
            font-size: 12px;
            color: #6b7280;
            border-top: 1px solid #e5e7eb;
            padding-top: 8px;
        }

        .link {
            stroke: #d1d5db;
            stroke-width: 1;
            stroke-opacity: 0.7;
            transition: all 0.3s ease;
        }

        .link.strong {
            stroke-width: 1.5;
            stroke: #9ca3af;
            stroke-opacity: 0.8;
        }

        .link:hover {
            stroke-opacity: 1;
            stroke: #6366f1;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 8px;
        }

        .modal-type {
            font-size: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #6b7280;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .close-modal:hover {
            color: #111827;
        }
    </style>
</head>
<body>
    <div id="graph-container">
        <div class="hover-preview" id="hoverPreview">
            <div class="preview-title" id="previewTitle"></div>
            <div class="preview-content" id="previewContent"></div>
            <div class="preview-meta" id="previewMeta"></div>
        </div>
    </div>

    <div class="modal" id="nodeModal">
        <div class="modal-content">
            <button class="close-modal">&times;</button>
            <div class="modal-header">
                <div class="modal-title" id="modalTitle"></div>
                <div class="modal-type" id="modalType"></div>
            </div>
            <div class="modal-body" id="modalBody"></div>
        </div>
    </div>

    <script>
        // Obsidian Vault Parser
        class ObsidianParser {
            constructor() {
                this.nodes = new Map();
                this.links = [];
                this.linkStrengths = new Map();
            }

            async parseVaultFiles(files) {
                // First pass: create all nodes
                for (let file of files) {
                    const fileName = file.name.replace('.md', '');
                    const content = await this.readFileContent(file);
                    
                    this.nodes.set(fileName, {
                        id: fileName.toLowerCase().replace(/\s+/g, '-'),
                        name: fileName,
                        type: 'page',
                        content: this.extractPreview(content),
                        rawContent: content,
                        connections: 0
                    });
                }

                // Second pass: extract links and create connections
                for (let [fileName, node] of this.nodes) {
                    const internalLinks = this.extractInternalLinks(node.rawContent);
                    const externalLinks = this.extractExternalLinks(node.rawContent);

                    // Process internal links
                    internalLinks.forEach(linkName => {
                        const targetNode = this.nodes.get(linkName);
                        if (targetNode) {
                            this.addLink(node.id, targetNode.id);
                        }
                    });

                    // Process external links
                    externalLinks.forEach(link => {
                        const externalId = this.createExternalNode(link.text || link.url, link.url);
                        this.addLink(node.id, externalId);
                    });
                }

                // Update connection counts
                this.updateConnectionCounts();

                return this.getGraphData();
            }

            async readFileContent(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsText(file);
                });
            }

            extractInternalLinks(content) {
                const linkRegex = /\[\[([^\]]+)\]\]/g;
                const links = [];
                let match;
                
                while ((match = linkRegex.exec(content)) !== null) {
                    links.push(match[1].trim());
                }
                
                return links;
            }

            extractExternalLinks(content) {
                const links = [];
                
                // Markdown links [text](url)
                const markdownRegex = /\[([^\]]*)\]\(([^)]+)\)/g;
                let match;
                while ((match = markdownRegex.exec(content)) !== null) {
                    links.push({ text: match[1], url: match[2] });
                }
                
                // Direct URLs
                const urlRegex = /https?:\/\/[^\s\)]+/g;
                while ((match = urlRegex.exec(content)) !== null) {
                    // Skip if already captured as markdown link
                    if (!content.substring(Math.max(0, match.index - 10), match.index).includes('](')) {
                        links.push({ url: match[0] });
                    }
                }
                
                return links;
            }

            extractPreview(content) {
                // Remove markdown syntax and get first 200 chars
                let preview = content
                    .replace(/\[\[([^\]]+)\]\]/g, '$1') // Remove [[ ]]
                    .replace(/\[([^\]]*)\]\([^)]+\)/g, '$1') // Remove markdown links
                    .replace(/#+\s*/g, '') // Remove headers
                    .replace(/\n+/g, ' ') // Replace newlines with spaces
                    .trim();
                
                return preview.length > 200 ? preview.substring(0, 200) + '...' : preview;
            }

            createExternalNode(name, url) {
                const id = 'ext-' + url.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
                
                if (!this.nodes.has(id)) {
                    const domain = new URL(url).hostname.replace('www.', '');
                    this.nodes.set(id, {
                        id: id,
                        name: name || domain,
                        type: 'external',
                        url: url,
                        content: `External link to ${domain}`,
                        connections: 0
                    });
                }
                
                return id;
            }

            addLink(sourceId, targetId) {
                const linkKey = `${sourceId}-${targetId}`;
                const reverseKey = `${targetId}-${sourceId}`;
                
                if (this.linkStrengths.has(linkKey)) {
                    this.linkStrengths.set(linkKey, this.linkStrengths.get(linkKey) + 1);
                } else if (this.linkStrengths.has(reverseKey)) {
                    this.linkStrengths.set(reverseKey, this.linkStrengths.get(reverseKey) + 1);
                } else {
                    this.linkStrengths.set(linkKey, 1);
                    this.links.push({ source: sourceId, target: targetId });
                }
            }

            updateConnectionCounts() {
                // Count connections for each node
                this.links.forEach(link => {
                    const sourceNode = Array.from(this.nodes.values()).find(n => n.id === link.source);
                    const targetNode = Array.from(this.nodes.values()).find(n => n.id === link.target);
                    
                    if (sourceNode) sourceNode.connections++;
                    if (targetNode) targetNode.connections++;
                });
            }

            getGraphData() {
                return {
                    nodes: Array.from(this.nodes.values()),
                    links: this.links.map(link => ({
                        ...link,
                        strength: this.linkStrengths.get(`${link.source}-${link.target}`) || 
                                 this.linkStrengths.get(`${link.target}-${link.source}`) || 1
                    }))
                };
            }
        }

        // File upload handler
        function setupFileUpload() {
            const container = document.getElementById('graph-container');
            
            // Create file upload area
            const uploadArea = document.createElement('div');
            uploadArea.innerHTML = `
                <div style="position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(255,255,255,0.9); padding: 20px; border-radius: 8px; border: 2px dashed #d1d5db;">
                    <input type="file" id="vaultFiles" multiple accept=".md" style="margin-bottom: 10px;">
                    <div style="font-size: 14px; color: #666;">
                        Upload your Obsidian .md files to generate the graph
                    </div>
                    <button id="parseButton" style="margin-top: 10px; padding: 8px 16px; background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Generate Graph
                    </button>
                </div>
            `;
            container.appendChild(uploadArea);

            document.getElementById('parseButton').addEventListener('click', async () => {
                const fileInput = document.getElementById('vaultFiles');
                const files = Array.from(fileInput.files);
                
                if (files.length === 0) {
                    alert('Please select some .md files first!');
                    return;
                }

                const parser = new ObsidianParser();
                const graphData = await parser.parseVaultFiles(files);
                
                // Hide upload area
                uploadArea.style.display = 'none';
                
                // Create new graph with parsed data
                new ObsidianGraph(graphData);
            });
        }

        class ObsidianGraph {
            constructor(data) {
                this.data = data;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.setupSVG();
                this.setupSimulation();
                this.setupZoom();
                this.setupModal();
                this.setupHoverPreview();
                this.render();
            }

            setupSVG() {
                this.svg = d3.select("#graph-container")
                    .append("svg")
                    .attr("width", this.width)
                    .attr("height", this.height);

                this.container = this.svg.append("g");
            }

            setupSimulation() {
                this.simulation = d3.forceSimulation(this.data.nodes)
                    .force("link", d3.forceLink(this.data.links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-150))
                    .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                    .force("collision", d3.forceCollide().radius(d => this.getNodeRadius(d) + 10));
            }

            setupZoom() {
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on("zoom", (event) => {
                        this.container.attr("transform", event.transform);
                    });

                this.svg.call(this.zoom);
            }

            setupModal() {
                const modal = d3.select("#nodeModal");
                d3.select(".close-modal").on("click", () => {
                    modal.style("display", "none");
                });

                modal.on("click", (event) => {
                    if (event.target === modal.node()) {
                        modal.style("display", "none");
                    }
                });
            }

            setupHoverPreview() {
                this.hoverPreview = d3.select("#hoverPreview");
                this.previewTitle = d3.select("#previewTitle");
                this.previewContent = d3.select("#previewContent");
                this.previewMeta = d3.select("#previewMeta");
            }

            getNodeRadius(d) {
                if (d.connections > 10) return 8;
                return 6;
            }

            getNodeClass(d) {
                if (d.connections > 10) return "node central";
                if (d.type === 'external') return "node external";
                return "node";
            }

            render() {
                // Links
                this.link = this.container.append("g")
                    .selectAll("line")
                    .data(this.data.links)
                    .join("line")
                    .attr("class", d => d.strength > 2 ? "link strong" : "link");

                // Nodes
                this.node = this.container.append("g")
                    .selectAll("g")
                    .data(this.data.nodes)
                    .join("g")
                    .attr("class", d => this.getNodeClass(d))
                    .call(this.drag());

                this.node.append("circle")
                    .attr("r", d => this.getNodeRadius(d));

                this.node.append("text")
                    .text(d => d.name)
                    .attr("dy", d => this.getNodeRadius(d) + 15)
                    .style("opacity", 0);

                // Click and hover handlers
                this.node.on("click", (event, d) => {
                    event.stopPropagation();
                    if (d.type === "external" && d.url) {
                        window.open(d.url, '_blank');
                    } else {
                        this.showModal(d);
                    }
                })
                .on("mouseenter", (event, d) => {
                    this.showHoverPreview(event, d);
                })
                .on("mouseleave", () => {
                    this.hideHoverPreview();
                })
                .on("mousemove", (event) => {
                    this.updateHoverPreviewPosition(event);
                });

                // Simulation tick
                this.simulation.on("tick", () => {
                    this.link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    this.node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });
            }

            drag() {
                return d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on("end", (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });
            }

            showModal(node) {
                const modal = d3.select("#nodeModal");
                d3.select("#modalTitle").text(node.name);
                d3.select("#modalType").text(node.type);
                
                let content = node.content || "No content available";
                if (node.type === "external" && node.url) {
                    content += `<br><br><a href="${node.url}" target="_blank" style="color: #6366f1;">Open Link →</a>`;
                }
                
                d3.select("#modalBody").html(content);
                modal.style("display", "flex");
            }

            showHoverPreview(event, node) {
                this.previewTitle.text(node.name);
                this.previewContent.text(node.content ? 
                    (node.content.length > 150 ? node.content.substring(0, 150) + "..." : node.content) : 
                    "No content available"
                );
                this.previewMeta.text(`${node.type} • ${node.connections} connections`);
                
                this.hoverPreview.classed("visible", true);
                this.updateHoverPreviewPosition(event);
            }

            hideHoverPreview() {
                this.hoverPreview.classed("visible", false);
            }

            updateHoverPreviewPosition(event) {
                const [mouseX, mouseY] = d3.pointer(event, document.body);
                const previewWidth = 300;
                const previewHeight = 120;
                
                let left = mouseX + 15;
                let top = mouseY - previewHeight / 2;
                
                // Keep preview within viewport
                if (left + previewWidth > window.innerWidth) {
                    left = mouseX - previewWidth - 15;
                }
                if (top < 10) top = 10;
                if (top + previewHeight > window.innerHeight) {
                    top = window.innerHeight - previewHeight - 10;
                }
                
                this.hoverPreview
                    .style("left", left + "px")
                    .style("top", top + "px");
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.svg.attr("width", this.width).attr("height", this.height);
                this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2));
                this.simulation.alpha(0.3).restart();
            }
        }

        // Initialize file upload on page load
        document.addEventListener('DOMContentLoaded', () => {
            setupFileUpload();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Will be handled by individual graph instances
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                d3.select("#nodeModal").style("display", "none");
            }
        });
    </script>
</body>
</html>
